name: Enhance release changelog with AI

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to test (e.g., v19.0.0)'
        required: true
        type: string
      dry_run:
        description: 'Dry run mode - generate changelog but do not update release'
        required: false
        type: boolean
        default: true

permissions:
  contents: write  # Update release body
  models: read     # Access GitHub Models API

jobs:
  enhance:
    name: Generate enhanced changelog
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (with tags)
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.tag || github.ref }}
          fetch-depth: 0
          fetch-tags: true

      - name: Gather release context
        id: ctx
        shell: bash
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GH_TOKEN: ${{ github.token }}
          INPUT_TAG: ${{ inputs.tag }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          set -euo pipefail
          # Determine if this is a manual dispatch or release event
          if [[ -n "$INPUT_TAG" ]]; then
            echo "📋 Manual dispatch mode - fetching release info for tag: $INPUT_TAG"
            # Manual dispatch: fetch release info for the specified tag
            CURRENT_TAG="$INPUT_TAG"
            RELEASE_JSON=$(gh api repos/${{ github.repository }}/releases/tags/$CURRENT_TAG || echo '{}')
            RELEASE_ID=$(printf "%s" "$RELEASE_JSON" | jq -r '.id // "0"')
            HTML_URL=$(printf "%s" "$RELEASE_JSON" | jq -r '.html_url // ""')
            EXISTING_BODY=$(printf "%s" "$RELEASE_JSON" | jq -r '.body // ""')
            echo "  Release ID: $RELEASE_ID"
            echo "  Release URL: $HTML_URL"
          else
            echo "📋 Release event mode - parsing from event payload"
            # Release event: parse from event payload
            CURRENT_TAG=$(jq -r '.release.tag_name' "$GITHUB_EVENT_PATH")
            RELEASE_ID=$(jq -r '.release.id' "$GITHUB_EVENT_PATH")
            HTML_URL=$(jq -r '.release.html_url' "$GITHUB_EVENT_PATH")
            EXISTING_BODY=$(jq -r '.release.body // ""' "$GITHUB_EVENT_PATH")
            echo "  Tag: $CURRENT_TAG"
            echo "  Release ID: $RELEASE_ID"
          fi
          # Persist to a file for later steps to source
          {
            echo "CURRENT_TAG=$CURRENT_TAG"
            echo "RELEASE_ID=$RELEASE_ID"
            echo "HTML_URL=$HTML_URL"
            echo "DRY_RUN=${DRY_RUN:-false}"
          } > ctx.env
          echo "✅ Context saved to ctx.env"
          # Save existing body as a file to avoid env escaping issues
          printf "%s" "$EXISTING_BODY" > existing_notes.md
          echo "✅ Existing notes saved ($(wc -l < existing_notes.md) lines)"

      - name: Determine diff range
        id: diff
        shell: bash
        run: |
          set -euo pipefail
          set -a; source ctx.env; set +a
          echo "🔍 Determining diff range for tag: $CURRENT_TAG"
          # Try to find the previous tag using git describe
          if PREV_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null); then
            BASE="$PREV_TAG"
            echo "  Previous tag found: $PREV_TAG"
          else
            # Fallback to initial commit
            BASE="$(git rev-list --max-parents=0 HEAD | tail -n 1)"
            echo "  No previous tag found, using initial commit: ${BASE:0:8}"
          fi
          echo "base_ref=$BASE" >> "$GITHUB_OUTPUT"
          echo "curr_ref=$CURRENT_TAG" >> "$GITHUB_OUTPUT"
          COMPARE_URL="https://github.com/${{ github.repository }}/compare/${BASE}...${CURRENT_TAG}"
          echo "compare_url=$COMPARE_URL" >> "$GITHUB_OUTPUT"
          echo "✅ Diff range: $BASE...$CURRENT_TAG"

      - name: Collect commits and changes
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ steps.diff.outputs.base_ref }}"
          HEAD="${{ steps.diff.outputs.curr_ref }}"
          echo "📝 Collecting commits and changes from $BASE to $HEAD"
          git log --no-merges --pretty=format:'%s' "${BASE}..${HEAD}" | head -n 500 > commits_subjects.txt || true
          echo "  ✅ Commit subjects: $(wc -l < commits_subjects.txt) commits"
          git log --no-merges --pretty=format:'- %s%n%b%n' "${BASE}..${HEAD}" | head -n 2000 > commits_detailed.txt || true
          echo "  ✅ Detailed commits: $(wc -l < commits_detailed.txt) lines"
          git diff --name-status "${BASE}..${HEAD}" | head -n 1000 > files_changed.txt || true
          echo "  ✅ Changed files: $(wc -l < files_changed.txt) files"
          git shortlog -sne "${BASE}..${HEAD}" | sed -E 's/^ *[0-9]+\t//g' | head -n 200 > contributors.txt || true
          echo "  ✅ Contributors: $(wc -l < contributors.txt) people"

      - name: Generate enhanced changelog with AI
        id: ai
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          set -a; source ctx.env; set +a
          echo "🤖 Generating enhanced changelog with AI"
          MODEL="openai/gpt-4o-mini"
          echo "  Model: $MODEL"
          SYSTEM_PROMPT=$(cat << 'PROMPT'
          You are a release notes editor for the open-source project "oh-my-posh", a cross-shell prompt theme engine written in Go.
          Write a clear, human-friendly Markdown changelog for this release. Use concise language and organize with headings.
          Goals:
          - Summarize highlights up front with context and impact.
          - Group changes using conventional commit types (Features, Fixes, Performance, Docs, Refactor, Revert, Build/CI, Chore), but merge minor types into a short 'Other' where appropriate.
          - Call out breaking changes and required migrations with explicit before/after examples or commands.
          - Add practical usage notes or snippets to help users adopt new features or changes.
          - Mention notable themes/config segments affected when you can infer from commits/file paths.
          - Credit contributors.
          - Provide 'Full diff' and 'Thanks' footer.
          Requirements:
          - Output valid Markdown only, no front matter, no HTML.
          - Keep to ~300-800 words unless there are many breaking changes.
          - Prefer code blocks for examples with proper language tags (bash, json, yaml, toml, powershell).
          - Do not invent features not present in the commits/diff.
          PROMPT
          )
          # Build the user content
          REPO="${{ github.repository }}"
          COMPARE_URL="${{ steps.diff.outputs.compare_url }}"
          CURR="$CURRENT_TAG"
          if PREV=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null); then :; else PREV="<none>"; fi
          EXISTING=$(cat existing_notes.md || true)
          SUBJECTS="$(cat commits_subjects.txt || true)"
          DETAILS="$(cat commits_detailed.txt || true)"
          FILES="$(cat files_changed.txt || true)"
          CONTRIBUTORS="$(cat contributors.txt || true)"
          USER_CONTENT=$(cat << EOF
          Repository: ${REPO}
          Release: ${CURR}
          Previous: ${PREV:-<none>}
          Release URL: ${HTML_URL}
          Compare URL: ${COMPARE_URL}

          Existing release notes (from conventional commits):
          ---
          ${EXISTING}
          ---

          Conventional commits (subjects):
          ---
          ${SUBJECTS}
          ---

          Commits (details):
          ---
          ${DETAILS}
          ---

          Changed files:
          ---
          ${FILES}
          ---

          Contributors:
          ---
          ${CONTRIBUTORS}
          ---
          EOF
          )
          echo "  Calling GitHub Models API..."
          OUTPUT_MD=""
          set +e
          RESP=$(curl -sS -f -X POST "https://models.github.ai/inference/chat/completions" \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg model "$MODEL" --arg sys "$SYSTEM_PROMPT" --arg user "$USER_CONTENT" '{model:$model, messages: [{role:"system",content:$sys},{role:"user",content:$user}], temperature: 0.2, max_tokens: 4000}')")
          CURL_EXIT=$?
          if [ $CURL_EXIT -eq 0 ]; then
            OUTPUT_MD=$(printf "%s" "$RESP" | jq -r '.choices[0].message.content // empty')
            echo "  ✅ API call successful"
          else
            echo "  ❌ API call failed with exit code: $CURL_EXIT"
            echo "  Response: $RESP"
          fi
          set -e
          if [[ -z "$OUTPUT_MD" ]]; then
            echo "❌ AI generation failed or no output produced."
            echo "enhanced_body=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "  Generated changelog length: $(printf "%s" "$OUTPUT_MD" | wc -c) characters"
          # Wrap with markers for idempotent updates and include compare link
          {
            echo "<!-- AI-ENHANCED-CHANGELOG:START -->"
            echo ""
            echo "$OUTPUT_MD"
            echo ""
            echo "_Full diff: ${COMPARE_URL}_"
            echo ""
            echo "<!-- AI-ENHANCED-CHANGELOG:END -->"
          } > enhanced_changelog.md
          echo "✅ Enhanced changelog saved to enhanced_changelog.md"
          echo "enhanced_body<<EOF" >> "$GITHUB_OUTPUT"
          cat enhanced_changelog.md >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "✅ Changelog saved to step output"

      - name: Update release body
        if: ${{ steps.ai.outputs.enhanced_body != '' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          set -a; source ctx.env; set +a
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "🧪 Dry run mode enabled - skipping release update"
            echo "   The generated changelog would be applied to release ID: ${RELEASE_ID}"
            exit 0
          fi
          echo "📝 Updating release body for release ID: ${RELEASE_ID}"
          # Fetch current release body
          gh api repos/${{ github.repository }}/releases/${RELEASE_ID} | jq -r '.body // ""' > current_body.md
          echo "  ✅ Fetched current release body"
          # Remove previous AI section if present
          awk '/<!-- AI-ENHANCED-CHANGELOG:START -->/{flag=1; next} /<!-- AI-ENHANCED-CHANGELOG:END -->/{flag=0; next} !flag { print }' current_body.md > clean_body.md
          echo "  ✅ Cleaned previous AI section"
          # Compose new body: AI section + previous body (cleaned)
          cat enhanced_changelog.md > merged.md
          echo "" >> merged.md
          cat clean_body.md >> merged.md
          echo "  ✅ Merged new changelog with existing content"
          PAYLOAD=$(jq -Rs '{body: .}' < merged.md)
          gh api -X PATCH repos/${{ github.repository }}/releases/${RELEASE_ID} -H "Content-Type: application/json" -d "$PAYLOAD"
          echo "✅ Release body updated successfully"

      - name: Summary
        if: ${{ steps.ai.outputs.enhanced_body != '' }}
        shell: bash
        run: |
          set -a; source ctx.env; set +a
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "## 🧪 Dry Run - Enhanced Changelog Preview" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Release would not be modified.** Below is the generated changelog:" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ✅ Enhanced Changelog Generated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Release body has been updated with AI-enhanced changelog:" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          cat enhanced_changelog.md >> $GITHUB_STEP_SUMMARY

      - name: Skipped notice
        if: ${{ steps.ai.outputs.enhanced_body == '' }}
        run: |
          echo "❌ AI changelog generation skipped or failed. Ensure GitHub Models access is enabled for this repo." >> $GITHUB_STEP_SUMMARY
